# 11-GenerateFormationBlendingService.ps1
# Generates FormationBlendingService with caching for formation pattern management
# Addresses critical gap: Formation Blending & Caching utility per audit requirements

param(
    [Parameter(Mandatory = $false)]
    [ValidateNotNullOrEmpty()]
    [string]$ProjectRoot = (Get-Location).Path,

    [Parameter(Mandatory = $false)]
    [switch]$WhatIf
)

# Import utilities with error handling
try {
    Import-Module "$PSScriptRoot/utils.psm1" -Force -ErrorAction Stop
} catch {
    Write-Error "Failed to import utils module: $($_.Exception.Message)"
    exit 1
}

Write-StepHeader "FORMATION BLENDING & CACHING SERVICE GENERATION"
Write-InfoLog "Generating formation blending service with intelligent caching"

# Validate project structure
try {
    Test-ProjectStructure -ProjectRoot $ProjectRoot -ErrorAction Stop
    Write-InfoLog "Project structure validation passed"
} catch {
    Write-ErrorLog "Project structure validation failed: $($_.Exception.Message)"
    exit 1
}

# Define formation service paths
$formationServicePath = Join-Path $ProjectRoot "src/domains/formation/services"
$formationTypesPath = Join-Path $ProjectRoot "src/domains/formation/types"
$formationUtilsPath = Join-Path $ProjectRoot "src/domains/formation/utils"

Write-InfoLog "Formation service paths:"
Write-InfoLog "  Services: $formationServicePath"
Write-InfoLog "  Types: $formationTypesPath"
Write-InfoLog "  Utils: $formationUtilsPath"

# Create directories if they don't exist
$directories = @($formationServicePath, $formationTypesPath, $formationUtilsPath)
foreach ($dir in $directories) {
    if (-not (Test-Path $dir)) {
        Write-InfoLog "Creating directory: $dir"
        if (-not $WhatIf) {
            New-Item -ItemType Directory -Path $dir -Force | Out-Null
        }
    }
}

# Generate Formation Blending types
$formationBlendingTypesContent = @'
/**
 * Formation Blending Types
 * Type definitions for formation pattern blending and caching
 */

import { Vector3 } from ''three'';

export interface IFormationBlendingService {
  blendFormations(formations: FormationPattern[], weights: number[]): FormationPattern;
  getCachedBlend(key: string): FormationPattern | null;
  setCachedBlend(key: string, pattern: FormationPattern): void;
  clearCache(): void;
  getCacheStats(): CacheStats;
  dispose(): void;
}

export interface FormationPattern {
  readonly id: string;
  readonly name: string;
  readonly positions: Vector3[];
  readonly metadata: FormationMetadata;
  readonly complexity: number;
}

export interface FormationMetadata {
  readonly type: FormationType;
  readonly symmetry: SymmetryType;
  readonly density: number;
  readonly scale: number;
  readonly rotation: Vector3;
}

export type FormationType =
  | ''spiral''
  | ''cluster''
  | ''grid''
  | ''wave''
  | ''organic''
  | ''geometric'';

export type SymmetryType =
  | ''none''
  | ''radial''
  | ''bilateral''
  | ''rotational''
  | ''translational'';

export interface BlendingConfig {
  readonly method: BlendingMethod;
  readonly smoothing: number;
  readonly preserveSymmetry: boolean;
  readonly normalizeWeights: boolean;
}

export type BlendingMethod =
  | ''linear''
  | ''cubic''
  | ''spherical''
  | ''weighted'';

export interface CacheConfig {
  readonly maxSize: number;
  readonly ttl: number; // Time to live in milliseconds
  readonly compressionEnabled: boolean;
}

export interface CacheStats {
  readonly size: number;
  readonly maxSize: number;
  readonly hitRate: number;
  readonly missRate: number;
  readonly totalRequests: number;
}

export interface CacheEntry {
  readonly pattern: FormationPattern;
  readonly timestamp: number;
  readonly accessCount: number;
  readonly size: number;
}
'@

$formationBlendingTypesFile = Join-Path $formationTypesPath "formationBlending.types.ts"
Write-InfoLog "Generating formation blending types: $formationBlendingTypesFile"
if (-not $WhatIf) {
    Set-Content -Path $formationBlendingTypesFile -Value $formationBlendingTypesContent -Encoding UTF8
    Write-SuccessLog "Created formation blending types file"
}

# Generate FormationBlendingService implementation (Part 1)
$formationBlendingServiceContent = @'
/**
 * Formation Blending Service
 * Advanced service for blending formation patterns with intelligent caching
 * Addresses critical gap: Formation Blending & Caching per audit requirements
 * Auto-generated by 11-GenerateFormationBlendingService.ps1
 */

import { Vector3 } from ''three'';
import { v4 as uuidv4 } from ''uuid'';
import { logger } from ''@/shared/utils/logger'';
import {
  IFormationBlendingService,
  FormationPattern,
  BlendingConfig,
  CacheConfig,
  CacheStats,
  CacheEntry,
  BlendingMethod
} from ''@/domains/formation/types/formationBlending.types'';

/**
 * Formation Blending Service
 * Handles formation pattern blending with LRU caching
 */
export class FormationBlendingService implements IFormationBlendingService {
  static #instance: FormationBlendingService | null = null;
  #isDisposed = false;
  #cache = new Map<string, CacheEntry>();
  #cacheStats = {
    hits: 0,
    misses: 0,
    totalRequests: 0
  };

  readonly #config: CacheConfig = {
    maxSize: 100,
    ttl: 300000, // 5 minutes
    compressionEnabled: true
  };

  readonly #defaultBlendingConfig: BlendingConfig = {
    method: ''weighted'' as BlendingMethod,
    smoothing: 0.5,
    preserveSymmetry: true,
    normalizeWeights: true
  };

  private constructor() {
    logger.info(''FormationBlendingService initialized'', {
      cacheConfig: this.#config
    });
  }

  /**
   * Get singleton instance
   */
  static getInstance(): FormationBlendingService {
    if (!FormationBlendingService.#instance) {
      FormationBlendingService.#instance = new FormationBlendingService();
    }
    return FormationBlendingService.#instance;
  }

  /**
   * Blend multiple formation patterns with weights
   */
  blendFormations(formations: FormationPattern[], weights: number[]): FormationPattern {
    this.#validateNotDisposed();

    if (!formations.length || formations.length !== weights.length) {
      throw new Error(''Invalid formations or weights for blending'');
    }

    // Generate cache key
    const cacheKey = this.#generateCacheKey(formations, weights);

    // Check cache first
    const cached = this.getCachedBlend(cacheKey);
    if (cached) {
      return cached;
    }

    // Perform blending
    const blended = this.#performBlending(formations, weights, this.#defaultBlendingConfig);

    // Cache result
    this.setCachedBlend(cacheKey, blended);

    logger.debug(''Formation blending completed'', {
      inputCount: formations.length,
      outputPositions: blended.positions.length,
      cacheKey
    });

    return blended;
  }

  /**
   * Get cached blend pattern
   */
  getCachedBlend(key: string): FormationPattern | null {
    this.#validateNotDisposed();
    this.#cacheStats.totalRequests++;

    const entry = this.#cache.get(key);
    if (!entry) {
      this.#cacheStats.misses++;
      return null;
    }

    // Check TTL
    if (Date.now() - entry.timestamp > this.#config.ttl) {
      this.#cache.delete(key);
      this.#cacheStats.misses++;
      return null;
    }

    this.#cacheStats.hits++;

    // Update access count
    const updatedEntry: CacheEntry = {
      ...entry,
      accessCount: entry.accessCount + 1
    };
    this.#cache.set(key, updatedEntry);

    return entry.pattern;
  }

  /**
   * Set cached blend pattern
   */
  setCachedBlend(key: string, pattern: FormationPattern): void {
    this.#validateNotDisposed();

    // Enforce cache size limit
    if (this.#cache.size >= this.#config.maxSize) {
      this.#evictLeastRecentlyUsed();
    }

    const entry: CacheEntry = {
      pattern,
      timestamp: Date.now(),
      accessCount: 1,
      size: this.#calculatePatternSize(pattern)
    };

    this.#cache.set(key, entry);
  }

  /**
   * Clear all cached patterns
   */
  clearCache(): void {
    this.#validateNotDisposed();

    const cacheSize = this.#cache.size;
    this.#cache.clear();
    this.#cacheStats = { hits: 0, misses: 0, totalRequests: 0 };

    logger.info(''Formation blending cache cleared'', { previousSize: cacheSize });
  }

  /**
   * Get cache statistics
   */
  getCacheStats(): CacheStats {
    this.#validateNotDisposed();

    const totalRequests = this.#cacheStats.totalRequests;
    return {
      size: this.#cache.size,
      maxSize: this.#config.maxSize,
      hitRate: totalRequests > 0 ? this.#cacheStats.hits / totalRequests : 0,
      missRate: totalRequests > 0 ? this.#cacheStats.misses / totalRequests : 0,
      totalRequests
    };
  }

  /**
   * Perform the actual blending operation
   */
  #performBlending(
    formations: FormationPattern[],
    weights: number[],
    config: BlendingConfig
  ): FormationPattern {
    // Normalize weights if requested
    const normalizedWeights = config.normalizeWeights
      ? this.#normalizeWeights(weights)
      : weights;

    // Find maximum position count for blending
    const maxPositions = Math.max(...formations.map(f => f.positions.length));
    const blendedPositions: Vector3[] = [];

    // Blend positions using weighted average
    for (let i = 0; i < maxPositions; i++) {
      const blendedPos = new Vector3();
      let totalWeight = 0;

      formations.forEach((formation, formationIndex) => {
        if (i < formation.positions.length) {
          const weight = normalizedWeights[formationIndex];
          const pos = formation.positions[i];

          blendedPos.add(pos.clone().multiplyScalar(weight));
          totalWeight += weight;
        }
      });

      if (totalWeight > 0) {
        blendedPos.divideScalar(totalWeight);
        blendedPositions.push(blendedPos);
      }
    }

    // Create blended formation
    return {
      id: uuidv4(),
      name: `Blended_$\{formations.length}_formations`,
      positions: blendedPositions,
      metadata: this.#blendMetadata(formations, normalizedWeights),
      complexity: this.#calculateComplexity(blendedPositions)
    };
  }

  /**
   * Generate cache key from formations and weights
   */
  #generateCacheKey(formations: FormationPattern[], weights: number[]): string {
    const formationIds = formations.map(f => f.id).sort().join(''|'');
    const weightStr = weights.map(w => w.toFixed(3)).join(''|'');
    return `$\{formationIds}:$\{weightStr}`;
  }

  /**
   * Normalize weights to sum to 1.0
   */
  #normalizeWeights(weights: number[]): number[] {
    const sum = weights.reduce((a, b) => a + b, 0);
    return sum > 0 ? weights.map(w => w / sum) : weights;
  }

  /**
   * Blend metadata from multiple formations
   */
  #blendMetadata(formations: FormationPattern[], weights: number[]) {
    // Use metadata from formation with highest weight
    const maxWeightIndex = weights.indexOf(Math.max(...weights));
    return formations[maxWeightIndex].metadata;
  }

  /**
   * Calculate pattern complexity
   */
  #calculateComplexity(positions: Vector3[]): number {
    return Math.min(positions.length / 10, 10); // Scale 0-10
  }

  /**
   * Calculate pattern memory size
   */
  #calculatePatternSize(pattern: FormationPattern): number {
    return pattern.positions.length * 12 + 100; // Rough estimate in bytes
  }

  /**
   * Evict least recently used cache entry
   */
  #evictLeastRecentlyUsed(): void {
    let oldestKey = '''';
    let oldestTime = Date.now();

    for (const [key, entry] of this.#cache.entries()) {
      if (entry.timestamp < oldestTime) {
        oldestTime = entry.timestamp;
        oldestKey = key;
      }
    }

    if (oldestKey) {
      this.#cache.delete(oldestKey);
    }
  }

  /**
   * Dispose of resources and reset singleton
   */
  dispose(): void {
    if (this.#isDisposed) return;

    logger.info(''FormationBlendingService disposing'', {
      cacheStats: this.getCacheStats()
    });

    this.clearCache();
    this.#isDisposed = true;
    FormationBlendingService.#instance = null;
  }

  /**
   * Validate service is not disposed
   */
  #validateNotDisposed(): void {
    if (this.#isDisposed) {
      throw new Error(''FormationBlendingService has been disposed'');
    }
  }
}

// Export singleton instance
export const formationBlendingService = FormationBlendingService.getInstance();
'@

$formationBlendingServiceFile = Join-Path $formationServicePath "FormationBlendingService.ts"
Write-InfoLog "Generating formation blending service: $formationBlendingServiceFile"
if (-not $WhatIf) {
    Set-Content -Path $formationBlendingServiceFile -Value $formationBlendingServiceContent -Encoding UTF8
    Write-SuccessLog "Created formation blending service file"
}

# Summary and completion
Write-InfoLog " "
Write-InfoLog "Formation Blending & Caching Service Generation Summary:"
Write-InfoLog "  Types: $formationBlendingTypesFile"
Write-InfoLog "  Service: $formationBlendingServiceFile"
Write-InfoLog " "

Write-SuccessLog "Formation Blending & Caching Service generation completed!"
Write-InfoLog "Gap 3 resolved: FormationBlendingService with intelligent caching per audit"