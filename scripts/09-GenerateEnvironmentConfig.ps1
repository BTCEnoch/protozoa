# 09-GenerateEnvironmentConfig.ps1
# Generates centralized environment configuration service for dev/prod API endpoints
# Addresses critical gap: Missing EnvConfigService for Bitcoin Ordinals API management

param(
    [Parameter(Mandatory = $false)]
    [ValidateNotNullOrEmpty()]
    [string]$ProjectRoot = (Get-Location).Path,
    
    [Parameter(Mandatory = $false)]
    [ValidateSet("development", "production", "both")]
    [string]$Environment = "both",
    
    [Parameter(Mandatory = $false)]
    [switch]$WhatIf
)

# Import utilities with error handling
try {
    Import-Module "$PSScriptRoot/utils.psm1" -Force -ErrorAction Stop
} catch {
    Write-Error "Failed to import utils module: $($_.Exception.Message)"
    exit 1
}

Write-StepHeader "ENVIRONMENT CONFIGURATION SERVICE GENERATION"
Write-InfoLog "Generating centralized environment configuration for Bitcoin Ordinals API endpoints"

# Validate project structure
try {
    Test-ProjectStructure -ProjectRoot $ProjectRoot -ErrorAction Stop
    Write-InfoLog "Project structure validation passed"
} catch {
    Write-ErrorLog "Project structure validation failed: $($_.Exception.Message)"
    exit 1
}

# Define environment configuration paths
$envConfigPath = Join-Path $ProjectRoot "src/shared/config"
$envServicePath = Join-Path $ProjectRoot "src/domains/bitcoin/services"
$envTypesPath = Join-Path $ProjectRoot "src/domains/bitcoin/types"

Write-InfoLog "Environment configuration paths:"
Write-InfoLog "  Config: $envConfigPath"
Write-InfoLog "  Service: $envServicePath" 
Write-InfoLog "  Types: $envTypesPath"

# Create directories if they don't exist
$directories = @($envConfigPath, $envServicePath, $envTypesPath)
foreach ($dir in $directories) {
    if (-not (Test-Path $dir)) {
        Write-InfoLog "Creating directory: $dir"
        if (-not $WhatIf) {
            New-Item -ItemType Directory -Path $dir -Force | Out-Null
        }
    }
}

# Generate environment configuration types
$envTypesContent = @"
/**
 * Environment Configuration Types
 * Centralized type definitions for dev/prod API endpoint management
 */

export interface IEnvironmentConfig {
  readonly environment: Environment;
  readonly apiEndpoints: ApiEndpoints;
  readonly features: FeatureFlags;
  readonly performance: PerformanceConfig;
}

export type Environment = 'development' | 'production' | 'test';

export interface ApiEndpoints {
  readonly ordinals: OrdinalsEndpoints;
  readonly bitcoin: BitcoinEndpoints;
}

export interface OrdinalsEndpoints {
  readonly baseUrl: string;
  readonly blockInfo: string;
  readonly content: string;
  readonly inscription: string;
}

export interface BitcoinEndpoints {
  readonly rpc: string;
  readonly explorer: string;
  readonly mempool: string;
}

export interface FeatureFlags {
  readonly enableCaching: boolean;
  readonly enableRetries: boolean;
  readonly enableLogging: boolean;
  readonly enableMetrics: boolean;
}

export interface PerformanceConfig {
  readonly cacheTimeout: number;
  readonly retryAttempts: number;
  readonly requestTimeout: number;
  readonly rateLimitDelay: number;
}

export interface IEnvironmentService {
  getConfig(): IEnvironmentConfig;
  getApiEndpoint(service: keyof ApiEndpoints, endpoint: string): string;
  isProduction(): boolean;
  isDevelopment(): boolean;
  dispose(): void;
}
"@

$envTypesFile = Join-Path $envTypesPath "environment.types.ts"
Write-InfoLog "Generating environment types: $envTypesFile"
if (-not $WhatIf) {
    Set-Content -Path $envTypesFile -Value $envTypesContent -Encoding UTF8
    Write-SuccessLog "Created environment types file"
}

# Generate environment configuration data
$envConfigContent = @"
/**
 * Environment Configuration Data
 * Centralized configuration for Bitcoin Ordinals API endpoints
 * Auto-generated by 09-GenerateEnvironmentConfig.ps1
 */

import { IEnvironmentConfig, Environment } from '@/domains/bitcoin/types/environment.types';

const isDevelopment = process.env.NODE_ENV === 'development';
const isProduction = process.env.NODE_ENV === 'production';
const isTest = process.env.NODE_ENV === 'test';

/**
 * Development Environment Configuration
 * Uses full URLs for external API access during development
 */
const developmentConfig: IEnvironmentConfig = {
  environment: 'development' as Environment,
  apiEndpoints: {
    ordinals: {
      baseUrl: 'https://ordinals.com',
      blockInfo: 'https://ordinals.com/r/blockinfo',
      content: 'https://ordinals.com/content',
      inscription: 'https://ordinals.com/inscription'
    },
    bitcoin: {
      rpc: 'https://blockstream.info/api',
      explorer: 'https://blockstream.info',
      mempool: 'https://mempool.space/api'
    }
  },
  features: {
    enableCaching: true,
    enableRetries: true,
    enableLogging: true,
    enableMetrics: true
  },
  performance: {
    cacheTimeout: 300000, // 5 minutes
    retryAttempts: 3,
    requestTimeout: 10000, // 10 seconds
    rateLimitDelay: 1000 // 1 second
  }
};

/**
 * Production Environment Configuration
 * Uses relative paths for optimized production deployment
 */
const productionConfig: IEnvironmentConfig = {
  environment: 'production' as Environment,
  apiEndpoints: {
    ordinals: {
      baseUrl: '',
      blockInfo: '/r/blockinfo',
      content: '/content',
      inscription: '/inscription'
    },
    bitcoin: {
      rpc: process.env.BITCOIN_RPC_URL || 'https://blockstream.info/api',
      explorer: process.env.BITCOIN_EXPLORER_URL || 'https://blockstream.info',
      mempool: process.env.MEMPOOL_URL || 'https://mempool.space/api'
    }
  },
  features: {
    enableCaching: true,
    enableRetries: true,
    enableLogging: false, // Reduced logging in production
    enableMetrics: true
  },
  performance: {
    cacheTimeout: 600000, // 10 minutes
    retryAttempts: 5,
    requestTimeout: 15000, // 15 seconds
    rateLimitDelay: 500 // 0.5 seconds
  }
};

/**
 * Test Environment Configuration
 * Minimal configuration for testing scenarios
 */
const testConfig: IEnvironmentConfig = {
  environment: 'test' as Environment,
  apiEndpoints: {
    ordinals: {
      baseUrl: 'http://localhost:3000',
      blockInfo: '/mock/blockinfo',
      content: '/mock/content',
      inscription: '/mock/inscription'
    },
    bitcoin: {
      rpc: 'http://localhost:8332',
      explorer: 'http://localhost:3001',
      mempool: 'http://localhost:3002'
    }
  },
  features: {
    enableCaching: false,
    enableRetries: false,
    enableLogging: true,
    enableMetrics: false
  },
  performance: {
    cacheTimeout: 1000, // 1 second
    retryAttempts: 1,
    requestTimeout: 5000, // 5 seconds
    rateLimitDelay: 0
  }
};

/**
 * Get current environment configuration
 */
export function getCurrentConfig(): IEnvironmentConfig {
  if (isTest) return testConfig;
  if (isProduction) return productionConfig;
  return developmentConfig;
}

export { developmentConfig, productionConfig, testConfig };
"@

$envConfigFile = Join-Path $envConfigPath "environment.config.ts"
Write-InfoLog "Generating environment configuration: $envConfigFile"
if (-not $WhatIf) {
    Set-Content -Path $envConfigFile -Value $envConfigContent -Encoding UTF8
    Write-SuccessLog "Created environment configuration file"
}

# Generate Environment Service (Part 1 - keeping under 200 lines)
$envServiceContent = @"
/**
 * Environment Configuration Service
 * Centralized service for managing dev/prod API endpoints
 * Implements singleton pattern with proper resource management
 * Auto-generated by 09-GenerateEnvironmentConfig.ps1
 */

import { logger } from '@/shared/utils/logger';
import { 
  IEnvironmentService, 
  IEnvironmentConfig, 
  ApiEndpoints 
} from '@/domains/bitcoin/types/environment.types';
import { getCurrentConfig } from '@/shared/config/environment.config';

/**
 * Environment Configuration Service
 * Manages environment-specific configuration and API endpoints
 */
export class EnvironmentService implements IEnvironmentService {
  static #instance: EnvironmentService | null = null;
  #config: IEnvironmentConfig;
  #isDisposed = false;

  private constructor() {
    this.#config = getCurrentConfig();
    logger.info('EnvironmentService initialized', {
      environment: this.#config.environment,
      features: this.#config.features
    });
  }

  /**
   * Get singleton instance
   */
  static getInstance(): EnvironmentService {
    if (!EnvironmentService.#instance) {
      EnvironmentService.#instance = new EnvironmentService();
    }
    return EnvironmentService.#instance;
  }

  /**
   * Get complete environment configuration
   */
  getConfig(): IEnvironmentConfig {
    this.#validateNotDisposed();
    return { ...this.#config };
  }

  /**
   * Get API endpoint URL for specific service and endpoint
   */
  getApiEndpoint(service: keyof ApiEndpoints, endpoint: string): string {
    this.#validateNotDisposed();
    
    const serviceConfig = this.#config.apiEndpoints[service];
    if (!serviceConfig) {
      throw new Error(`Unknown service: $\{service}`);
    }

    const baseUrl = serviceConfig.baseUrl;
    const endpointPath = serviceConfig[endpoint as keyof typeof serviceConfig] as string;
    
    if (!endpointPath) {
      throw new Error(`Unknown endpoint '$\{endpoint}' for service '$\{service}'`);
    }

    const fullUrl = baseUrl ? `$\{baseUrl}$\{endpointPath}` : endpointPath;
    
    logger.debug('API endpoint resolved', {
      service,
      endpoint,
      url: fullUrl,
      environment: this.#config.environment
    });

    return fullUrl;
  }

  /**
   * Check if running in production environment
   */
  isProduction(): boolean {
    this.#validateNotDisposed();
    return this.#config.environment === 'production';
  }

  /**
   * Check if running in development environment
   */
  isDevelopment(): boolean {
    this.#validateNotDisposed();
    return this.#config.environment === 'development';
  }

  /**
   * Dispose of resources and reset singleton
   */
  dispose(): void {
    if (this.#isDisposed) return;

    logger.info('EnvironmentService disposing');
    this.#isDisposed = true;
    EnvironmentService.#instance = null;
  }

  /**
   * Validate service is not disposed
   */
  #validateNotDisposed(): void {
    if (this.#isDisposed) {
      throw new Error('EnvironmentService has been disposed');
    }
  }
}

// Export singleton instance
export const environmentService = EnvironmentService.getInstance();
"@

$envServiceFile = Join-Path $envServicePath "EnvironmentService.ts"
Write-InfoLog "Generating environment service: $envServiceFile"
if (-not $WhatIf) {
    Set-Content -Path $envServiceFile -Value $envServiceContent -Encoding UTF8
    Write-SuccessLog "Created environment service file"
}

# Summary and completion
Write-InfoLog ""
Write-InfoLog "Environment Configuration Generation Summary:"
Write-InfoLog "  Types: $envTypesFile"
Write-InfoLog "  Config: $envConfigFile"
Write-InfoLog "  Service: $envServiceFile"
Write-InfoLog ""

Write-SuccessLog "Environment Configuration Service generation completed!"
Write-InfoLog "Gap 1 resolved: Centralized EnvConfigService for dev/prod API endpoints" 