# 18a-SetupLoggingService.ps1
# Ensures Winston logging infrastructure is present in src/shared/lib/logger.ts
# If file already exists (generated by previous scripts), the script validates and updates dependencies.
# Usage: Executed by runAll.ps1 right after environment configuration generation.

[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory = $false)]
    [string]$ProjectRoot = (Split-Path $PSScriptRoot -Parent),

    [Parameter(Mandatory = $false)]
    [switch]$DryRun
)

$ErrorActionPreference = "Stop"

try {
    Import-Module "$PSScriptRoot\utils.psm1" -Force -ErrorAction Stop
} catch {
    Write-Error "Failed to import utils module: $($_.Exception.Message)"
    exit 1
}

try {
    Write-StepHeader "Setup Winston Logging Service (18a)"
    Write-InfoLog "Verifying central Winston logger implementation"

    $libPath = Join-Path $ProjectRoot "src/shared/lib"
    $loggerPath = Join-Path $libPath "logger.ts"

    if (-not (Test-Path $libPath)) {
        Write-InfoLog "Creating shared lib directory: $libPath"
        if (-not $DryRun) { 
            New-Item -ItemType Directory -Path $libPath -Force | Out-Null 
        }
    }

    # Create the logger content
    $loggerContent = @"
/**
 * Central Winston Logger
 * Auto-generated by 18a-SetupLoggingService.ps1
 */

import { createLogger, format, transports } from 'winston'
import { environmentService } from '@/shared/config/environmentService'
import type { LogLevel } from '@/shared/types/loggingTypes'

const { combine, timestamp, errors, json, colorize, simple, printf, splat } = format

function buildLogger(serviceName = 'protozoa'): ReturnType<typeof createLogger> {
  const env = environmentService.getMode()
  const debugCfg = environmentService.getDebugConfig()
  const level: LogLevel = (debugCfg.verbose ? 'debug' : 'info') as LogLevel

  const baseTransports: any[] = [
    new transports.Console({
      format: combine(colorize(), simple(), splat(), printf(({ level, message }) => `${level}: ${message}`))
    })
  ]

  if (environmentService.isProduction()) {
    baseTransports.push(
      new transports.File({ filename: 'logs/error.log', level: 'error' }),
      new transports.File({ filename: 'logs/combined.log' })
    )
  }

  return createLogger({
    level,
    format: combine(timestamp(), errors({ stack: true }), splat(), json()),
    defaultMeta: { service: serviceName, env },
    transports: baseTransports
  })
}

export const logger = buildLogger()
export function createServiceLogger(service: string) {
  return logger.child({ service })
}
"@

    if (Test-Path $loggerPath) {
        Write-InfoLog "logger.ts already exists - validating header"
        $existingContent = Get-Content $loggerPath -Raw
        if (-not ($existingContent | Select-String -Pattern "Central Winston Logger")) {
            Write-WarningLog "Existing logger.ts detected but header missing - backing up and overwriting"
            Backup-File -FilePath $loggerPath | Out-Null
            if (-not $DryRun) { 
                Set-Content -Path $loggerPath -Value $loggerContent -Encoding UTF8 
            }
        }
    } else {
        Write-InfoLog "Creating logger.ts"
        if (-not $DryRun) { 
            Set-Content -Path $loggerPath -Value $loggerContent -Encoding UTF8 
        }
    }

    # Ensure package.json has winston dependencies
    $pkgJsonPath = Join-Path $ProjectRoot "package.json"
    
    Write-InfoLog "Checking package.json at: $pkgJsonPath"
    
    if (Test-Path $pkgJsonPath) {
        Write-InfoLog "Loading existing package.json"
        try {
            $pkgJson = Get-Content $pkgJsonPath -Raw | ConvertFrom-Json
            Write-InfoLog "Successfully loaded package.json"
        } catch {
            Write-ErrorLog "Failed to parse package.json: $($_.Exception.Message)"
            throw
        }
    } else {
        Write-InfoLog "Creating new package.json structure"
        $pkgJson = [PSCustomObject]@{ 
            name = "protozoa"
            version = "0.0.1"
            scripts = [PSCustomObject]@{}
            dependencies = [PSCustomObject]@{}
            devDependencies = [PSCustomObject]@{}
        }
    }

    # Ensure dependencies object exists
    if (-not $pkgJson.dependencies) {
        $pkgJson | Add-Member -MemberType NoteProperty -Name "dependencies" -Value ([PSCustomObject]@{}) -Force
    }
    if (-not $pkgJson.devDependencies) {
        $pkgJson | Add-Member -MemberType NoteProperty -Name "devDependencies" -Value ([PSCustomObject]@{}) -Force
    }

    # Add winston dependency
    if (-not ($pkgJson.dependencies | Get-Member -Name "winston" -ErrorAction SilentlyContinue)) { 
        $pkgJson.dependencies | Add-Member -MemberType NoteProperty -Name "winston" -Value "^3.11.0" -Force
        Write-InfoLog "Added winston dependency"
    }
    
    # Add @types/winston dependency
    $typesWinstonName = "@types/winston"
    if (-not ($pkgJson.devDependencies | Get-Member -Name $typesWinstonName -ErrorAction SilentlyContinue)) { 
        $pkgJson.devDependencies | Add-Member -MemberType NoteProperty -Name $typesWinstonName -Value "^2.4.4" -Force
        Write-InfoLog "Added @types/winston devDependency"
    }

    if (-not $DryRun) {
        try {
            $jsonOutput = $pkgJson | ConvertTo-Json -Depth 20
            Set-Content -Path $pkgJsonPath -Value $jsonOutput -Encoding UTF8
            Write-SuccessLog "package.json updated with Winston dependencies"
        } catch {
            Write-ErrorLog "Failed to write package.json: $($_.Exception.Message)"
            throw
        }
    } else {
        Write-InfoLog "DryRun mode - package.json not modified"
    }

    Write-SuccessLog "Winston logging setup complete"
    exit 0

} catch {
    Write-ErrorLog "SetupLoggingService failed: $($_.Exception.Message)"
    exit 1
} 