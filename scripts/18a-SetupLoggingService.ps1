# 18a-SetupLoggingService.ps1
# Ensures Winston logging infrastructure is present in src/shared/lib/logger.ts
# If file already exists (generated by previous scripts), the script validates and updates dependencies.
# Usage: Executed by runAll.ps1 right after environment configuration generation.

[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory = $false)]
    [string]$ProjectRoot = (Split-Path $PSScriptRoot -Parent),

    [Parameter(Mandatory = $false)]
    [switch]$WhatIf
)

try {
    Import-Module "$PSScriptRoot\utils.psm1" -Force -ErrorAction Stop
} catch {
    Write-Error "Failed to import utils module: $($_.Exception.Message)"
    exit 1
}

$ErrorActionPreference = "Stop"

try {
    Write-StepHeader "Setup Winston Logging Service (18a)"
    Write-InfoLog "Verifying central Winston logger implementation"

    $libPath = Join-Path $ProjectRoot "src/shared/lib"
    $loggerPath = Join-Path $libPath "logger.ts"

    if (-not (Test-Path $libPath)) {
        Write-InfoLog "Creating shared lib directory: $libPath"
        if (-not $WhatIf) { New-Item -ItemType Directory -Path $libPath -Force | Out-Null }
    }

    $loggerContent = @"
/**
 * Central Winston Logger
 * Auto-generated by 18a-SetupLoggingService.ps1
 */

import { createLogger, format, transports } from 'winston'
import { environmentService } from '@/shared/config/environmentService'
import type { LogLevel } from '@/shared/types/loggingTypes'

const { combine, timestamp, errors, json, colorize, simple, printf, splat } = format

function buildLogger(serviceName = 'protozoa'): ReturnType<typeof createLogger> {
  const env = environmentService.getMode()
  const debugCfg = environmentService.getDebugConfig()
  const level: LogLevel = (debugCfg.verbose ? 'debug' : 'info') as LogLevel

  const baseTransports: any[] = [
    new transports.Console({
      format: combine(colorize(), simple(), splat(), printf(({ level, message }) => `${level}: ${message}`))
    })
  ]

  if (environmentService.isProduction()) {
    baseTransports.push(
      new transports.File({ filename: 'logs/error.log', level: 'error' }),
      new transports.File({ filename: 'logs/combined.log' })
    )
  }

  return createLogger({
    level,
    format: combine(timestamp(), errors({ stack: true }), splat(), json()),
    defaultMeta: { service: serviceName, env },
    transports: baseTransports
  })
}

export const logger = buildLogger()
export function createServiceLogger(service: string) {
  return logger.child({ service })
}
"@

    if (Test-Path $loggerPath) {
        Write-InfoLog "logger.ts already exists – validating header"
        if (-not (Get-Content $loggerPath -Raw | Select-String -Pattern "Central Winston Logger")) {
            Write-WarningLog "Existing logger.ts detected but header missing – backing up and overwriting"
            Backup-File -FilePath $loggerPath | Out-Null
            if (-not $WhatIf) { Set-Content -Path $loggerPath -Value $loggerContent -Encoding UTF8 }
        }
    } else {
        Write-InfoLog "Creating logger.ts"
        if (-not $WhatIf) { Set-Content -Path $loggerPath -Value $loggerContent -Encoding UTF8 }
    }

    # Ensure package.json has winston deps
    $pkgJsonPath = Join-Path $ProjectRoot "package.json"
    if (Test-Path $pkgJsonPath) {
        $pkgJson = Get-Content $pkgJsonPath -Raw | ConvertFrom-Json
    } else {
        $pkgJson = @{ name = "protozoa"; version = "0.0.1"; scripts = @{}; dependencies = @{}; devDependencies = @{} }
    }

    if (-not $pkgJson.dependencies.winston) { $pkgJson.dependencies.winston = "^3.11.0" }
    if (-not $pkgJson.devDependencies."@types/winston") { $pkgJson.devDependencies."@types/winston" = "^2.4.4" }

    if (-not $WhatIf) {
        $pkgJson | ConvertTo-Json -Depth 20 | Set-Content -Path $pkgJsonPath -Encoding UTF8
        Write-SuccessLog "package.json updated with Winston dependencies"
    } else {
        Write-InfoLog "WhatIf mode – package.json not modified"
    }

    Write-SuccessLog "Winston logging setup complete"
    exit 0
} catch {
    Write-ErrorLog "SetupLoggingService failed: $($_.Exception.Message)"
    exit 1
}