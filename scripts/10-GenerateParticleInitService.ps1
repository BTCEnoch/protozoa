THIS SHOULD BE A LINTER ERROR# 10-GenerateParticleInitService.ps1
# Generates ParticleInitService to extract initialization logic from ParticleService
# Addresses critical gap: ParticleInitService extraction per audit requirements

param(
    [Parameter(Mandatory = $false)]
    [ValidateNotNullOrEmpty()]
    [string]$ProjectRoot = (Get-Location).Path,

    [Parameter(Mandatory = $false)]
    [switch]$WhatIf
)

# Import utilities with error handling
try {
    Import-Module "$PSScriptRoot/utils.psm1" -Force -ErrorAction Stop
} catch {
    Write-Error "Failed to import utils module: $($_.Exception.Message)"
    exit 1
}

Write-StepHeader "PARTICLE INITIALIZATION SERVICE GENERATION"
Write-InfoLog "Extracting particle initialization logic into dedicated service"

# Validate project structure
try {
    Test-ProjectStructure -ProjectRoot $ProjectRoot -ErrorAction Stop
    Write-InfoLog "Project structure validation passed"
} catch {
    Write-ErrorLog "Project structure validation failed: $($_.Exception.Message)"
    exit 1
}

# Define particle service paths
$particleServicePath = Join-Path $ProjectRoot "src/domains/particle/services"
$particleTypesPath = Join-Path $ProjectRoot "src/domains/particle/types"

Write-InfoLog "Particle service paths:"
Write-InfoLog "  Services: $particleServicePath"
Write-InfoLog "  Types: $particleTypesPath"

# Create directories if they don't exist
$directories = @($particleServicePath, $particleTypesPath)
foreach ($dir in $directories) {
    if (-not (Test-Path $dir)) {
        Write-InfoLog "Creating directory: $dir"
        if (-not $WhatIf) {
            New-Item -ItemType Directory -Path $dir -Force | Out-Null
        }
    }
}

# Generate ParticleInit types
$particleInitTypesContent = @'
/**
 * Particle Initialization Types
 * Type definitions for particle initialization and lifecycle management
 */

import { Vector3 } from "three";

export interface IParticleInitConfig {
  readonly position: Vector3;
  readonly velocity: Vector3;
  readonly mass: number;
  readonly radius: number;
  readonly lifespan: number;
  readonly traits: ParticleTraits;
}

export interface ParticleTraits {
  readonly color: string;
  readonly opacity: number;
  readonly energy: number;
  readonly stability: number;
  readonly reactivity: number;
}

export interface IParticleInitService {
  initializeParticle(config: IParticleInitConfig): IParticle;
  initializeFromBlockData(blockData: any): IParticle;
  createRandomParticle(bounds: BoundingBox): IParticle;
  validateInitConfig(config: IParticleInitConfig): boolean;
  dispose(): void;
}

export interface IParticle {
  readonly id: string;
  readonly position: Vector3;
  readonly velocity: Vector3;
  readonly mass: number;
  readonly radius: number;
  readonly traits: ParticleTraits;
  lifespan: number;
  age: number;
  isAlive: boolean;
}

export interface BoundingBox {
  readonly min: Vector3;
  readonly max: Vector3;
}

export interface InitializationResult {
  readonly success: boolean;
  readonly particle?: IParticle;
  readonly error?: string;
}
'@

$particleInitTypesFile = Join-Path $particleTypesPath "particleInit.types.ts"
Write-InfoLog "Generating particle initialization types: $particleInitTypesFile"
if (-not $WhatIf) {
    Set-Content -Path $particleInitTypesFile -Value $particleInitTypesContent -Encoding UTF8
    Write-SuccessLog "Created particle initialization types file"
}

# Generate ParticleInitService implementation
$particleInitServiceContent = @'
/**
 * Particle Initialization Service
 * Dedicated service for particle initialization and lifecycle management
 * Extracted from ParticleService per architectural audit requirements
 * Auto-generated by 10-GenerateParticleInitService.ps1
 */

import { Vector3 } from "three";
import { v4 as uuidv4 } from "uuid";
import { logger } from "@/shared/utils/logger";
import { rngService } from "@/domains/rng/services/RNGService";
import {
  IParticleInitService,
  IParticleInitConfig,
  IParticle,
  ParticleTraits,
  BoundingBox,
  InitializationResult
} from "@/domains/particle/types/particleInit.types";

/**
 * Particle Initialization Service
 * Handles all particle creation and initialization logic
 */
export class ParticleInitService implements IParticleInitService {
  static #instance: ParticleInitService | null = null;
  #isDisposed = false;
  #particleCount = 0;

  private constructor() {
    logger.info("ParticleInitService initialized");
  }

  /**
   * Get singleton instance
   */
  static getInstance(): ParticleInitService {
    if (!ParticleInitService.#instance) {
      ParticleInitService.#instance = new ParticleInitService();
    }
    return ParticleInitService.#instance;
  }

  /**
   * Initialize particle with provided configuration
   */
  initializeParticle(config: IParticleInitConfig): IParticle {
    this.#validateNotDisposed();

    if (!this.validateInitConfig(config)) {
      throw new Error("Invalid particle initialization configuration");
    }

    const particle: IParticle = {
      id: uuidv4(),
      position: config.position.clone(),
      velocity: config.velocity.clone(),
      mass: config.mass,
      radius: config.radius,
      traits: { ...config.traits },
      lifespan: config.lifespan,
      age: 0,
      isAlive: true
    };

    this.#particleCount++;

    logger.debug("Particle initialized", {
      id: particle.id,
      position: particle.position,
      mass: particle.mass,
      totalParticles: this.#particleCount
    });

    return particle;
  }

  /**
   * Initialize particle from Bitcoin block data
   */
  initializeFromBlockData(blockData: any): IParticle {
    this.#validateNotDisposed();

    if (!blockData || !blockData.nonce) {
      throw new Error("Invalid block data for particle initialization");
    }

    // Seed RNG with block nonce for deterministic traits
    const seededRng = rngService.createSeededGenerator(blockData.nonce);

    const config: IParticleInitConfig = {
      position: new Vector3(
        seededRng() * 100 - 50,
        seededRng() * 100 - 50,
        seededRng() * 100 - 50
      ),
      velocity: new Vector3(
        (seededRng() - 0.5) * 10,
        (seededRng() - 0.5) * 10,
        (seededRng() - 0.5) * 10
      ),
      mass: seededRng() * 5 + 1,
      radius: seededRng() * 2 + 0.5,
      lifespan: Math.floor(seededRng() * 1000) + 500,
      traits: this.#generateTraitsFromBlockData(blockData, seededRng)
    };

    logger.info("Particle initialized from block data", {
      blockHeight: blockData.height,
      nonce: blockData.nonce,
      particleId: "pending"
    });

    return this.initializeParticle(config);
  }

  /**
   * Create random particle within bounds
   */
  createRandomParticle(bounds: BoundingBox): IParticle {
    this.#validateNotDisposed();

    const rng = rngService.getRandom();

    const config: IParticleInitConfig = {
      position: new Vector3(
        bounds.min.x + rng() * (bounds.max.x - bounds.min.x),
        bounds.min.y + rng() * (bounds.max.y - bounds.min.y),
        bounds.min.z + rng() * (bounds.max.z - bounds.min.z)
      ),
      velocity: new Vector3(
        (rng() - 0.5) * 5,
        (rng() - 0.5) * 5,
        (rng() - 0.5) * 5
      ),
      mass: rng() * 3 + 0.5,
      radius: rng() * 1.5 + 0.3,
      lifespan: Math.floor(rng() * 800) + 200,
      traits: this.#generateRandomTraits(rng)
    };

    return this.initializeParticle(config);
  }

  /**
   * Validate particle initialization configuration
   */
  validateInitConfig(config: IParticleInitConfig): boolean {
    this.#validateNotDisposed();

    if (!config) return false;
    if (!config.position || !config.velocity) return false;
    if (config.mass <= 0 || config.radius <= 0) return false;
    if (config.lifespan <= 0) return false;
    if (!config.traits) return false;

    return true;
  }

  /**
   * Generate traits from Bitcoin block data
   */
  #generateTraitsFromBlockData(blockData: any, rng: () => number): ParticleTraits {
    const hash = blockData.hash || ''";
    const hashValue = parseInt(hash.substring(0, 8), 16) || 0;

    return {
      color: `hsl($\{hashValue % 360}, 70%, 50%)`,
      opacity: 0.3 + (rng() * 0.7),
      energy: rng() * 100,
      stability: (hashValue % 100) / 100,
      reactivity: rng() * 10
    };
  }

  /**
   * Generate random particle traits
   */
  #generateRandomTraits(rng: () => number): ParticleTraits {
    return {
      color: `hsl($\{Math.floor(rng() * 360)}, 70%, 50%)`,
      opacity: 0.2 + (rng() * 0.8),
      energy: rng() * 100,
      stability: rng(),
      reactivity: rng() * 10
    };
  }

  /**
   * Dispose of resources and reset singleton
   */
  dispose(): void {
    if (this.#isDisposed) return;

    logger.info("ParticleInitService disposing", {
      totalParticlesCreated: this.#particleCount
    });

    this.#isDisposed = true;
    this.#particleCount = 0;
    ParticleInitService.#instance = null;
  }

  /**
   * Validate service is not disposed
   */
  #validateNotDisposed(): void {
    if (this.#isDisposed) {
      throw new Error("ParticleInitService has been disposed'');
    }
  }
}

// Export singleton instance
export const particleInitService = ParticleInitService.getInstance();
'@

$particleInitServiceFile = Join-Path $particleServicePath "ParticleInitService.ts"
Write-InfoLog "Generating particle initialization service: $particleInitServiceFile"
if (-not $WhatIf) {
    Set-Content -Path $particleInitServiceFile -Value $particleInitServiceContent -Encoding UTF8
    Write-SuccessLog "Created particle initialization service file"
}

# Summary and completion
Write-InfoLog "Processing step completed"
Write-InfoLog "Particle Initialization Service Generation Summary:"
Write-InfoLog "  Types: $particleInitTypesFile"
Write-InfoLog "  Service: $particleInitServiceFile"
Write-InfoLog "Processing step completed"

Write-SuccessLog "Particle Initialization Service generation completed!"
Write-InfoLog "Gap 2 resolved: ParticleInitService extracted from ParticleService per audit"

