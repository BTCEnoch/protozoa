/**
 * @fileoverview PersistenceService Implementation
 * @description Multi-layer persistence service with localStorage and IndexedDB support
 * @author Protozoa Development Team  
 * @version 1.0.0
 */

import { IPersistenceService } from "@/shared/interfaces/IPersistenceService";
import { createServiceLogger } from "@/shared/lib/logger";

/**
 * Storage operation result interface
 */
interface StorageResult<T = any> {
  success: boolean;
  data?: T;
  error?: string;
}

/**
 * Storage configuration interface
 */
interface StorageConfig {
  useIndexedDB: boolean;
  dbName: string;
  dbVersion: number;
  fallbackToLocalStorage: boolean;
}

/**
 * PersistenceService implementing multi-layer data persistence
 * Supports both localStorage and IndexedDB with intelligent fallback
 * Follows singleton pattern for application-wide consistency
 */
export class PersistenceService implements IPersistenceService {
  private static instance: PersistenceService;
  private readonly logger = createServiceLogger('PersistenceService');
  private db: IDBDatabase | null = null;
  private readonly config: StorageConfig;
  private initializationPromise: Promise<void> | null = null;

  /**
   * Private constructor enforcing singleton pattern
   */
  private constructor(config: Partial<StorageConfig> = {}) {
    this.config = {
      useIndexedDB: true,
      dbName: 'ProtozooaDB',
      dbVersion: 1,
      fallbackToLocalStorage: true,
      ...config
    };
    
    this.logger.info('PersistenceService initialized', this.config);
    this.initializationPromise = this.initializeStorage();
  }

  /**
   * Get the singleton instance of PersistenceService
   */
  public static getInstance(config?: Partial<StorageConfig>): PersistenceService {
    if (!PersistenceService.instance) {
      PersistenceService.instance = new PersistenceService(config);
    }
    return PersistenceService.instance;
  }

  /**
   * Initialize storage systems
   */
  private async initializeStorage(): Promise<void> {
    if (this.config.useIndexedDB && this.isIndexedDBSupported()) {
      try {
        await this.initializeIndexedDB();
        this.logger.info('IndexedDB initialized successfully');
      } catch (error) {
        this.logger.warn('IndexedDB initialization failed, falling back to localStorage', error);
        if (!this.config.fallbackToLocalStorage) {
          throw error;
        }
      }
    }
  }

  /**
   * Check if IndexedDB is supported
   */
  private isIndexedDBSupported(): boolean {
    return typeof window !== 'undefined' && 'indexedDB' in window;
  }

  /**
   * Initialize IndexedDB connection
   */
  private async initializeIndexedDB(): Promise<void> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.config.dbName, this.config.dbVersion);
      
      request.onerror = () => {
        reject(new Error(`IndexedDB open failed: ${request.error?.message}`));
      };

      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };

      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result;
        
        // Create object store for general data
        if (!db.objectStoreNames.contains('data')) {
          db.createObjectStore('data', { keyPath: 'key' });
        }
        
        // Create object store for large objects
        if (!db.objectStoreNames.contains('largeData')) {
          db.createObjectStore('largeData', { keyPath: 'key' });
        }
      };
    });
  }

  /**
   * Save data to storage
   */
  public async save<T>(key: string, value: T): Promise<StorageResult<T>> {
    try {
      await this.ensureInitialized();
      
      const serializedValue = this.serialize(value);
      const dataSize = new Blob([serializedValue]).size;
      
      // Use IndexedDB for large data or if configured
      if (this.db && (dataSize > 5000 || this.config.useIndexedDB)) {
        return await this.saveToIndexedDB(key, value, dataSize > 50000);
      }
      
      // Fallback to localStorage
      return this.saveToLocalStorage(key, serializedValue);
      
    } catch (error) {
      this.logger.error(`Failed to save data for key: ${key}`, error);
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
    }
  }

  /**
   * Load data from storage
   */
  public async load<T = any>(key: string): Promise<StorageResult<T>> {
    try {
      await this.ensureInitialized();
      
      // Try IndexedDB first if available
      if (this.db) {
        const result = await this.loadFromIndexedDB<T>(key);
        if (result.success) {
          return result;
        }
      }
      
      // Fallback to localStorage
      return this.loadFromLocalStorage<T>(key);
      
    } catch (error) {
      this.logger.error(`Failed to load data for key: ${key}`, error);
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
    }
  }

  /**
   * Remove data from storage
   */
  public async remove(key: string): Promise<StorageResult<boolean>> {
    try {
      await this.ensureInitialized();
      
      let success = false;
      
      // Remove from IndexedDB if available
      if (this.db) {
        const idbResult = await this.removeFromIndexedDB(key);
        success = idbResult.success || success;
      }
      
      // Remove from localStorage
      const lsResult = this.removeFromLocalStorage(key);
      success = lsResult.success || success;
      
      return { success, data: success };
      
    } catch (error) {
      this.logger.error(`Failed to remove data for key: ${key}`, error);
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
    }
  }

  /**
   * Clear all stored data
   */
  public async clear(): Promise<StorageResult<boolean>> {
    try {
      await this.ensureInitialized();
      
      let success = false;
      
      // Clear IndexedDB if available
      if (this.db) {
        const idbResult = await this.clearIndexedDB();
        success = idbResult.success || success;
      }
      
      // Clear localStorage
      const lsResult = this.clearLocalStorage();
      success = lsResult.success || success;
      
      this.logger.info('Storage cleared successfully');
      return { success, data: success };
      
    } catch (error) {
      this.logger.error('Failed to clear storage', error);
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
    }
  }

  /**
   * Get storage statistics
   */
  public async getStats(): Promise<{
    localStorageUsed: number;
    indexedDBSupported: boolean;
    indexedDBConnected: boolean;
  }> {
    const stats = {
      localStorageUsed: this.getLocalStorageUsage(),
      indexedDBSupported: this.isIndexedDBSupported(),
      indexedDBConnected: this.db !== null
    };
    
    this.logger.debug('Storage statistics retrieved', stats);
    return stats;
  }

  /**
   * Ensure storage is initialized
   */
  private async ensureInitialized(): Promise<void> {
    if (this.initializationPromise) {
      await this.initializationPromise;
      this.initializationPromise = null;
    }
  }

  /**
   * Serialize data for storage
   */
  private serialize<T>(data: T): string {
    return JSON.stringify(data);
  }

  /**
   * Deserialize data from storage
   */
  private deserialize<T>(data: string): T {
    return JSON.parse(data);
  }

  /**
   * Get localStorage usage in bytes
   */
  private getLocalStorageUsage(): number {
    let total = 0;
    for (const key in localStorage) {
      if (localStorage.hasOwnProperty(key)) {
        total += localStorage.getItem(key)?.length || 0;
      }
    }
    return total;
  }

  // Additional private methods for IndexedDB and localStorage operations would continue here...
  // (Truncated for length - would include saveToIndexedDB, loadFromIndexedDB, etc.)

  /**
   * Dispose of resources
   */
  public dispose(): void {
    if (this.db) {
      this.db.close();
      this.db = null;
    }
    this.logger.info('PersistenceService disposed');
  }
}

// Export factory function for consistency
export function createPersistenceService(config?: Partial<StorageConfig>): PersistenceService {
  return PersistenceService.getInstance(config);
} 