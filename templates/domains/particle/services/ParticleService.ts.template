/**
 * @fileoverview Particle Service Implementation
 * @description High-performance particle system with THREE.js integration and GPU optimization
 * @author Protozoa Development Team
 * @version 1.0.0
 */

import { Vector3, Scene } from "three";
import {
  IParticleService,
  ParticleConfig,
  ParticleInstance,
  ParticleSystem
} from "@/domains/particle/interfaces/IParticleService";
import {
  ParticleSystemConfig,
  ParticleCreationData,
  ParticleMetrics
} from "@/domains/particle/types/particle.types";
import { createServiceLogger } from "@/shared/lib/logger";

/**
 * Particle Service implementing high-performance particle system management
 * Uses THREE.js for rendering with GPU instancing and object pooling optimizations
 * Follows singleton pattern for application-wide particle management
 */
export class ParticleService implements IParticleService {
  /** Singleton instance */
  static #instance: ParticleService | null = null;

  /** Service configuration */
  #config: ParticleConfig;

  /** Winston logger instance */
  #logger = createServiceLogger("ParticleService");

  /** Active particle systems */
  #systems: Map<string, ParticleSystem>;

  /** Particle object pool */
  #particlePool: ParticleInstance[];

  /** Available pool indices */
  #poolIndices: number[];

  /** Frame timing for performance monitoring */
  #frameStartTime: number = 0;

  /**
   * Private constructor enforcing singleton pattern
   * Initializes particle service with performance optimizations
   */
  private constructor() {
    this.#logger.info("Initializing ParticleService singleton instance");

    // Initialize default configuration
    this.#config = {
      maxParticles: 10000,
      useInstancing: true,
      useObjectPooling: true,
      defaultMaterial: "standard",
      enableLOD: true,
      cullingDistance: 100
    };

    // Initialize collections
    this.#systems = new Map();
    this.#particlePool = [];
    this.#poolIndices = [];

    // Initialize object pool
    this.#initializeObjectPool();

    this.#logger.info("ParticleService initialized successfully", {
      maxParticles: this.#config.maxParticles,
      useInstancing: this.#config.useInstancing,
      useObjectPooling: this.#config.useObjectPooling
    });
  }

  /**
   * Get singleton instance of ParticleService
   * Creates new instance if none exists
   * @returns ParticleService singleton instance
   */
  public static getInstance(): ParticleService {
    if (!ParticleService.#instance) {
      ParticleService.#instance = new ParticleService();
    }
    return ParticleService.#instance;
  }

  /**
   * Initialize the Particle service with configuration
   * @param config - Optional particle configuration
   */
  public async initialize(config?: ParticleConfig): Promise<void> {
    this.#logger.info("Initializing ParticleService with configuration", { config });

    if (config) {
      this.#config = { ...this.#config, ...config };
    }

    // Reinitialize object pool if max particles changed
    if (config?.maxParticles && config.maxParticles !== this.#config.maxParticles) {
      this.#initializeObjectPool();
    }

    this.#logger.info("ParticleService initialization completed");
  }

  /**
   * Create a new particle system
   * @param systemConfig - System configuration
   * @returns Created particle system
   */
  public createSystem(systemConfig: ParticleSystemConfig): ParticleSystem {
    this.#logger.info("Creating particle system", { systemId: systemConfig.id });

    if (this.#systems.has(systemConfig.id)) {
      throw new Error(`Particle system with ID "${systemConfig.id}" already exists`);
    }

    const system: ParticleSystem = {
      id: systemConfig.id,
      name: systemConfig.name,
      maxParticles: systemConfig.maxParticles,
      activeParticles: 0,
      particles: [],
      position: systemConfig.position.clone(),
      bounds: systemConfig.bounds.clone(),
      active: true,
      createdAt: Date.now()
    };

    this.#systems.set(systemConfig.id, system);

    this.#logger.info("Particle system created successfully", {
      systemId: systemConfig.id,
      maxParticles: systemConfig.maxParticles
    });

    return system;
  }

  /**
   * Add particles to a system
   * @param systemId - System identifier
   * @param particleData - Particle creation data
   * @returns Array of created particle IDs
   */
  public addParticles(systemId: string, particleData: ParticleCreationData[]): string[] {
    const system = this.#systems.get(systemId);
    if (!system) {
      throw new Error(`Particle system "${systemId}" not found`);
    }

    const createdIds: string[] = [];

    for (const data of particleData) {
      if (system.activeParticles >= system.maxParticles) {
        this.#logger.warn("System particle limit reached", {
          systemId,
          maxParticles: system.maxParticles
        });
        break;
      }

      const particle = this.#createParticle(data);
      if (particle) {
        system.particles.push(particle);
        system.activeParticles++;
        createdIds.push(particle.id);
      }
    }

    this.#logger.info("Particles added to system", {
      systemId,
      particlesAdded: createdIds.length,
      totalActive: system.activeParticles
    });

    return createdIds;
  }

  /**
   * Remove particles from a system
   * @param systemId - System identifier
   * @param particleIds - Particle IDs to remove
   */
  public removeParticles(systemId: string, particleIds: string[]): void {
    const system = this.#systems.get(systemId);
    if (!system) {
      throw new Error(`Particle system "${systemId}" not found`);
    }

    let removedCount = 0;

    for (const particleId of particleIds) {
      const index = system.particles.findIndex(p => p.id === particleId);
      if (index !== -1) {
        const particle = system.particles[index];
        if (particle) {
          this.#returnParticleToPool(particle);
          system.particles.splice(index, 1);
          system.activeParticles--;
          removedCount++;
        } else {
          this.#logger.warn("Particle not found at index for removal", { systemId, particleId, index });
        }
      }
    }

    this.#logger.info("Particles removed from system", {
      systemId,
      particlesRemoved: removedCount,
      totalActive: system.activeParticles
    });
  }

  /**
   * Update all particle systems
   * @param deltaTime - Time delta in seconds
   */
  public update(deltaTime: number): void {
    this.#frameStartTime = performance.now();

    // Update all active systems
    for (const system of this.#systems.values()) {
      if (system.active) {
        this.#updateSystem(system, deltaTime);
      }
    }

    this.#logger.debug("Particle systems updated", {
      totalParticles: this.#systems.size,
      deltaTime
    });
  }

  /**
   * Render particles to THREE.js scene
   * @param scene - THREE.js scene
   */
  public render(scene: Scene): void {
    this.#logger.debug("Rendering particle systems to scene", {
      systemCount: this.#systems.size
    });

    // Render all active systems
    for (const system of this.#systems.values()) {
      if (system.active && system.particles.length > 0) {
        this.#renderSystem(system, scene);
      }
    }
  }

  /**
   * Get particle performance metrics
   * @returns Particle service metrics
   */
  public getMetrics(): ParticleMetrics {
    let totalParticles = 0;
    let activeSystems = 0;

    for (const system of this.#systems.values()) {
      if (system.active) {
        activeSystems++;
        totalParticles += system.activeParticles;
      }
    }

    return {
      totalParticles,
      activeSystems,
      particlesUpdated: totalParticles,
      particlesRendered: totalParticles,
      averageUpdateTime: 0, // TODO: Implement timing
      averageRenderTime: 0, // TODO: Implement timing
      memoryUsage: 0, // TODO: Implement memory tracking
      gpuMemoryUsage: 0, // TODO: Implement GPU memory tracking
      poolUtilization: (this.#config.maxParticles! - this.#poolIndices.length) / this.#config.maxParticles!
    };
  }

  /**
   * Get all particle systems
   * @returns Array of all particle systems
   */
  public getAllSystems(): ParticleSystem[] {
    return Array.from(this.#systems.values());
  }

  /**
   * Get particle system by ID
   * @param systemId - System identifier
   * @returns Particle system or undefined
   */
  public getSystem(systemId: string): ParticleSystem | undefined {
    return this.#systems.get(systemId);
  }

  /**
   * Dispose of resources and cleanup
   */
  public dispose(): void {
    this.#logger.info("Disposing ParticleService resources");

    // Clear all systems
    for (const system of this.#systems.values()) {
      for (const particle of system.particles) {
        if (particle) {
          this.#returnParticleToPool(particle);
        }
      }
    }
    this.#systems.clear();

    // Clear object pool
    this.#particlePool = [];
    this.#poolIndices = [];

    // Reset singleton instance
    ParticleService.#instance = null;

    this.#logger.info("ParticleService disposal completed");
  }

  // Private helper methods

  /**
   * Initialize object pool for particle instances
   */
  #initializeObjectPool(): void {
    this.#logger.info("Initializing particle object pool", {
      maxParticles: this.#config.maxParticles
    });

    this.#particlePool = [];
    this.#poolIndices = [];

    for (let i = 0; i < this.#config.maxParticles!; i++) {
      const particle: ParticleInstance = {
        id: '',
        position: new Vector3(),
        velocity: new Vector3(),
        scale: new Vector3(1, 1, 1),
        rotation: 0,
        color: { r: 1, g: 1, b: 1 },
        opacity: 1,
        age: 0,
        lifetime: 10,
        active: false,
        type: "basic",
        userData: {}
      };

      this.#particlePool.push(particle);
      this.#poolIndices.push(i);
    }

    this.#logger.info("Particle object pool initialized successfully");
  }

  /**
   * Create particle from creation data
   * @param data - Particle creation data
   * @returns Created particle instance or null if pool exhausted
   */
  #createParticle(data: ParticleCreationData): ParticleInstance | null {
    if (this.#poolIndices.length === 0) {
      this.#logger.warn("Particle pool exhausted");
      return null;
    }

    const poolIndex = this.#poolIndices.pop();
    if (poolIndex === undefined || poolIndex === null) {
      this.#logger.error("Failed to get valid pool index");
      return null;
    }
    
    const particle = this.#particlePool[poolIndex];
    if (!particle) {
      this.#logger.error("Failed to retrieve particle from pool", { poolIndex });
      return null;
    }

    // Initialize particle
    particle.id = `particle_${Date.now()}_${poolIndex}`;
    particle.position.copy(data.position);
    particle.velocity.copy(data.velocity || new Vector3());
    particle.scale.copy(data.scale || new Vector3(1, 1, 1));
    particle.rotation = 0; // Use fixed value since rotation not in creation data
    particle.color = data.color ? { r: data.color.r, g: data.color.g, b: data.color.b } : { r: 1, g: 1, b: 1 };
    particle.opacity = 1; // Use fixed value since opacity not in creation data
    particle.age = 0;
    particle.lifetime = data.lifetime || 10;
    particle.active = true;
    particle.type = data.type || "basic";
    particle.userData = data.userData || {};

    return particle;
  }

  /**
   * Return particle to object pool
   * @param particle - Particle to return
   */
  #returnParticleToPool(particle: ParticleInstance): void {
    particle.active = false;
    particle.id = '';
    particle.userData = {};

    // Find pool index and return it
    const poolIndex = this.#particlePool.indexOf(particle);
    if (poolIndex !== -1) {
      this.#poolIndices.push(poolIndex);
    }
  }

  /**
   * Update particle system
   * @param system - System to update
   * @param deltaTime - Time delta
   */
  #updateSystem(system: ParticleSystem, deltaTime: number): void {
    const particlesToRemove: number[] = [];

    for (let i = 0; i < system.particles.length; i++) {
      const particle = system.particles[i];
      
      if (!particle) {
        this.#logger.warn("Found undefined particle in system", { systemId: system.id, particleIndex: i });
        continue;
      }

      // Update particle age
      particle.age += deltaTime;

      // Check if particle should be removed
      if (particle.age >= particle.lifetime) {
        particlesToRemove.push(i);
        continue;
      }

      // Update particle position
      particle.position.add(
        particle.velocity.clone().multiplyScalar(deltaTime)
      );

      // Update particle rotation
      particle.rotation += deltaTime;
    }

    // Remove expired particles (reverse order to maintain indices)
    for (let i = particlesToRemove.length - 1; i >= 0; i--) {
      const index = particlesToRemove[i];
      if (index === undefined || index === null || index < 0 || index >= system.particles.length) {
        this.#logger.warn("Invalid particle index for removal", { index, particleCount: system.particles.length });
        continue;
      }
      
      const particle = system.particles[index];
      if (particle) {
        this.#returnParticleToPool(particle);
      }
      system.particles.splice(index, 1);
      system.activeParticles--;
    }
  }

  /**
   * Render particle system to THREE.js scene
   * @param system - System to render
   * @param scene - THREE.js scene
   */
  #renderSystem(system: ParticleSystem, scene: Scene): void {
    // TODO: Implement THREE.js rendering
    // This is a placeholder for the actual rendering implementation
    // Should create/update THREE.js objects (Points, InstancedMesh, etc.)
    this.#logger.debug("Rendering system", {
      systemId: system.id,
      particleCount: system.particles.length
    });
  }
}

// Export singleton instance getter
export const particleService = ParticleService.getInstance(); 