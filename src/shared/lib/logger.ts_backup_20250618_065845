/**
 * Logging Service Implementation
 * Winston-based logging with standardized levels and formatting
 * Used across all domain services for consistent logging
 */

import winston from 'winston';
import { ILogger, LogLevel, ILogEntry, IPerformanceMetrics } from '@/shared/types/loggingTypes';
import { environmentService } from './environmentService';

/**
 * Create a service-specific logger instance
 */
export function createServiceLogger(serviceName: string): ILogger {
  const debugConfig = environmentService.getDebugConfig();
  
  const logger = winston.createLogger({
    level: debugConfig.verbose ? 'debug' : 'info',
    format: winston.format.combine(
      winston.format.timestamp(),
      winston.format.errors({ stack: true }),
      winston.format.json(),
      winston.format.printf(({ timestamp, level, message, service, ...meta }) => {
        const logEntry: Partial<ILogEntry> = {
          timestamp: new Date(timestamp),
          level: level as LogLevel,
          message,
          service: service || serviceName,
          metadata: meta
        };
        return JSON.stringify(logEntry);
      })
    ),
    defaultMeta: { service: serviceName },
    transports: [
      new winston.transports.Console({
        format: winston.format.combine(
          winston.format.colorize(),
          winston.format.simple(),
          winston.format.printf(({ timestamp, level, message, service, ...meta }) => {
            const metaStr = Object.keys(meta).length ? JSON.stringify(meta) : '';
            return ${timestamp} [] :  ;
          })
        )
      })
    ]
  });

  // Add file transport in production
  if (environmentService.isProduction()) {
    logger.add(new winston.transports.File({
      filename: 'logs/error.log',
      level: 'error'
    }));
    logger.add(new winston.transports.File({
      filename: 'logs/combined.log'
    }));
  }

  return {
    debug: (message: string, metadata?: Record<string, any>) => {
      logger.debug(message, metadata);
    },
    info: (message: string, metadata?: Record<string, any>) => {
      logger.info(message, metadata);
    },
    warn: (message: string, metadata?: Record<string, any>) => {
      logger.warn(message, metadata);
    },
    error: (message: string, error?: Error, metadata?: Record<string, any>) => {
      logger.error(message, { error: error?.message, stack: error?.stack, ...metadata });
    }
  };
}

/**
 * Create a performance logger for metrics tracking
 */
export function createPerformanceLogger(serviceName: string): {
  debug: (message: string, metrics?: IPerformanceMetrics) => void;
  measureOperation: <T>(operation: string, fn: () => T) => T;
  measureAsyncOperation: <T>(operation: string, fn: () => Promise<T>) => Promise<T>;
} {
  const logger = createServiceLogger(${serviceName}_PERF);
  const debugConfig = environmentService.getDebugConfig();
  
  return {
    debug: (message: string, metrics?: IPerformanceMetrics) => {
      if (debugConfig.performanceLogging) {
        logger.debug(message, metrics);
      }
    },
    
    measureOperation: <T>(operation: string, fn: () => T): T => {
      if (!debugConfig.performanceLogging) {
        return fn();
      }
      
      const startTime = performance.now();
      const startMemory = (performance as any).memory?.usedJSHeapSize || 0;
      
      try {
        const result = fn();
        const endTime = performance.now();
        const endMemory = (performance as any).memory?.usedJSHeapSize || 0;
        
        const metrics: IPerformanceMetrics = {
          operation,
          duration: endTime - startTime,
          memoryDelta: endMemory - startMemory
        };
        
        logger.debug(Operation completed: , metrics);
        return result;
      } catch (error) {
        const endTime = performance.now();
        logger.error(Operation failed: , error as Error, {
          duration: endTime - startTime
        });
        throw error;
      }
    },
    
    measureAsyncOperation: async <T>(operation: string, fn: () => Promise<T>): Promise<T> => {
      if (!debugConfig.performanceLogging) {
        return fn();
      }
      
      const startTime = performance.now();
      const startMemory = (performance as any).memory?.usedJSHeapSize || 0;
      
      try {
        const result = await fn();
        const endTime = performance.now();
        const endMemory = (performance as any).memory?.usedJSHeapSize || 0;
        
        const metrics: IPerformanceMetrics = {
          operation,
          duration: endTime - startTime,
          memoryDelta: endMemory - startMemory
        };
        
        logger.debug(Async operation completed: , metrics);
        return result;
      } catch (error) {
        const endTime = performance.now();
        logger.error(Async operation failed: , error as Error, {
          duration: endTime - startTime
        });
        throw error;
      }
    }
  };
}

/**
 * Create an error logger for centralized error handling
 */
export function createErrorLogger(serviceName: string): {
  logError: (error: Error, context?: Record<string, any>) => void;
  logWarning: (message: string, context?: Record<string, any>) => void;
} {
  const logger = createServiceLogger(${serviceName}_ERROR);
  
  return {
    logError: (error: Error, context?: Record<string, any>) => {
      logger.error(Error in , error, context);
    },
    
    logWarning: (message: string, context?: Record<string, any>) => {
      logger.warn(Warning in : , context);
    }
  };
}
